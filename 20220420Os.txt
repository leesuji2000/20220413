#실제 프로세스: 리눅스 예시
	프로세스간 공간은 완전히 분리되어있다.
	실제 메모리 공간과 다른 가상주소를 만들고, 가상주소를 메모리주소(물리주소)로 바꾼다
	사용자 모드에서 커널 모드를 절대 접근 불가하다.
	커널 공간은 메모리 주소에서 공유가 가능하다.(프로세스마다 다른 커널 공간을 사용하면 공간  낭비

#다양한 IPC기법-IPC(interProcess Communcaton)
-file(실시간 불가능, 저장매체 저하_
이래는 커널 공간에서 공유)
-message queqe
-shared memory
-pipe
-signal
-semaphore
-socket

//여러 프로세스 동시 실행을 통한 성능 개선, 복잡한 프로그램을 위한 프로세스간 통신필요
	(병렬처리해서 속도를 빠르게, 직접 프로세스끼리 접근은 해킹문제)
//프로세스간 공간이 완전 분리
//프로세스간 통신을 위한 기법 IPC(커널 공간을 공유해서 기법사용)

#각각의 IPC기법

#파이프: 기본 파이프는 단방향통신
 #fork() 시스템콜이 호출되면 새로운 코드가 복사되어서 pc는 복사본 프로세스(코드)를 가리킨다
	두개를 구분할 수 있도록 리턴값을 다르게 했다(프로세스 ID 리턴 값이 다르게)
	두개의 코드는 같아도 동작을 다르게 하도록 만든다.(리턴으로 구분하여)
-부모 프로세스에서 fd[1]을 write해서 사용하고ㅓ
-fork()함수를 이용해서 자식 프로세스 fd[0]을 만들고 read를 사용해서 데이터를 읽을 수 있다.
-부모에서 read할 수 없고 자식에서 write할 수 없다. 그리고 데이터는 커널공간에 있어서
	파이프를 이용(단방향 부모->자식)

#메시지 큐:  큐이기 때문에 FIFO정책으로 데이터 전송
-넣는 프로세스 A 나가는 프로세스 B라고 할때
-A 프로세스에서는 B프로세스로 정보를 전달한다.

#파이프와 메시지큐 차이
-메시지 큐는 부모,자식이 아니라 
	키값을 통해서 서로 통신한다. 어느 프로세스 간에도 데이터 송수신이 가능(먼저넣은 데이터가 먼저 읽힌다)
-파이프는 단반향, 메시지큐는 양방향
//둘다 커널공간 공유

//메모리 공간도 커널공간과, 사용자공간으로 나뉘어 있따.

#공유 메모리: 
-노골적으로 커널공간에 메모리 공간을 만들고, 해당 공간을 변수처럼 쓰는 방식(포인터비슷)
-메시지 큐처럼 FIFO가 아니라, 해당 메모리 주소에 변수처럼 접근(공유메모리 key값으로 여러 프로세스에 접근)

자주 사용하는 두가지-시그널, 소켓
#시그널
-유닉스에서 30년된 전통 기법
-커널 또는 프로세스에서 다른 프로세스에 어떤 이벤트가 발생되었는지 알려주는 기법
-프로세스 관련 코드에 관련 시그널 핸들러를 등록해서, 해당 시그널 처리 실행
-미리 정의가 된 시그널(이벤트)가 있다
	-sigkill: 프로세스를 죽여라(슈퍼관리자가 사용하는 시그널로, 프로세스를 중단하도록)
	-sigcont:멈춘 프로세스를 실행해라 등등 여러 이벤트(함수)를 정의해 놨다.
-프로세스 관련 코드에 관련 시스너 핸들러를 등록해서, 해당 시그널 처리 실행
-PCB에 해당 프로세스가 블록, 처리해야하는 시그널 관련 정보를 관리(저장)한다.
	커널모드에서 사용자모드로 변환할떄 시그널 함수를 사용한다.
 
#소켓: 네트워크 통신을 위한 기술
-기본적으로 클라이언트와 서버등 두개의 다른 컴퓨터간의 네트워크 기반 통신 기술
-네트워크 통신을 할 수 있는 시스템 콜이라고 할 수 있다.
-컴퓨터안에서 또다른 프로세스끼리 데이터를 주고 받을 수 있어서 IPC기법으로 쓰이기도 한다.

//다양한 IPC기법을 황용해서 프로세스간의 통신 가능
//IPC기법으로 나온 것은 아니지만 시그널, 소켓을 IPC기법으로도 활용한다.
//실제 관련 코드에 대해서는 시스템 프로그래밍을 통해 실습 과정을 진행


컴퓨터 프로그램 실행과정
//소스코드를 컴파일 하면 실행파일이 생성
//실행파일을 실행하기 위해서 일반 사용자는 쉘(CLI, GUI)를 이용해서 실행해달라고 함
//프로세스가 ready상태에 있다가 스케줄러 지시에 따라서 running 상태로 바뀐다
//컴퓨터 코드를 짤때 IO접근은 1번해서 메모리에 다 업로드 시키고 작업을 하는것이 시간효율

1. 응용프로그래머
2. 시스템 프로그래머
3. 하드웨어 개발자
//3종류의 개발자가 있다

#스레드(thread)
-light weight process라고도 함
-프로세스: 프로세스 사이에 데이터 접근 불가
-스레드: 
	하나의 프로세스에 여러개의 스테드 생성가능
	스레드들은 동시에 실행가능
	프로세스 안에 있으므로, 프로세스는 데이터를 모두 접근가능
	스택공간에 스레드공간을 만들고, 각 스레드는 각각 다른 pc를 가리킴(서로 같이 공유가능)

하나의 프로세스에서 생성된 스레드만 공유가능하고 다른 프로세스에서 생선된건 공유불가
-스테드는 레지스터랑 스택이 따로 있고, 코드와 데이터를 공유한다.
-포직스posix스레드에서 제공하는 스레드 함수 사용

#멀티스레드
-소프트웨어 병령작업처리를 위해 멀티스레드를 사용
부모 스레드와 자식스레드를 만들어서 병렬로 데이터 공유

#멀티태스킹:cpu한개로 여러개의 프로세스가 교체되면서 실행(동시성처럼 보임)
#멀티프로세싱: 하나의(또는 여러) 프로세스를 여러개의 cpu를 사용해서 병렬시행(시간단축)
	멀티프로세싱에서 프로세스를 여러개로 쪼개어 여러 cpu에 실행시키는데
	이것을 스레드를 이용해서 구현한ㄷ.
 //스레드는 멀티core를 구현할때 잘 사용된다.



#스레드 장점
1. 사용자에 대한 응답성 향상(하나의 프로세스를 두개의 스레드로 나누어 각각에 스레드(요구에 응답하기 빠름)
	웹서버에서 사용자들이 요청할때, 각각의 요청에 바로 데이터를 주기 위해서 새로운 프로세스, 스레드를 복사해서 각각 응답
2. 자원 공유 효율: IPC 없이 자원공유가능
	프로세스 6개보다 프로세스 안에 스레드 6개가 더 자원효율
3. 작업이 분리되어 코드가 간결
	사실 

#스레드 단점
1. 스레드 중에서 한 스레드만 문제가 있어도 전체 프로세스 영향
2. 스레드를 많이 생성하면, context switching이 많이 일어나서 성능 저하
	스레드를 많이 생성하면, 모든 슷레드를 스케줄링 해야해서 복잡도 즈악

#스레드와 프로세스
-스레드: 서브셋, 프로세스 자원 공유, 주소영역 공유, IPC기법 필요없음
-프로세스: 독립적, 각각 독립적 자원, 자신만의 주소영역, IPC사용


#스레드 동기화 이슈 예제
-A B C 스레드를 실행할때 변수가 변하는 것을 공유하기 때문에
원하는 결과가 안나올 수 있다. -> 동기화 이슈(synchfonization)
-동기화를 해결하기 위한 함수들이 존재한다.

#동기화synchronization
-동기화: 작업들 사이에 실행시가를 맞춰야한다. = mutual exclusion(상호배제)
	쓰레드는 프로세스 모든 데이터를 접근할 수 있으므로
	-여러 스레드가 변경하는 공유 변수에 대해서 exclusivw access필요
	-어드 한 스레드가 공유 변수를 갱신하는 동안 다른 스레드가 동시접근하지 못하도록 막아라
#상호배제
-임계 자원(critical resource): 다른 스레드가 올 수없는 데이터
-임계 영역(critical section): 다른 스레드가 올 수 있는 공간

#동기화와 세마포어
-임계구역에 대한 접근을 막기위해 Locking메커니즘이 필요
	-카운터를 두어서 동시에 리소스에 접근할 수 있는 허용 가능한 스레드 수 제한
#세마포어
-리눅스에서 몇개가 들어오면 제할할지 정해둠
	포직스 세마포어에서 함수가 정의되어있다.
-임계영역에 어떻게 제한할 수 있는지 알 필요가 있따.
 -p: 검사(lock.acquire) -임계역역 들어감
-v:증가(lock.release) -임계 영역 나옴
-s:세마포어값

세마포어 수도코드
P(s) : wait(s) {
	while s <= 0 //바쁜대기
	s--
}
=>무한루프 해결: 운영체제 기술로 보완(대기큐)

#스레드_교착상태(deadlock)와 기아상태(starvration)

#deadlock:무한대기상태: 두개 이상의 작업이 서로 끝나기를 기다면서 다음단계까 진행된지 못함
-deadlock발생조건
	-mutual exclusion:프로세스들이 필요로 하는 자원에 대해 배타적인 통제권 요구
	-hold and wait: 프로세스가 할당된 자원을 가진 상태에서 다른 자원을 기다림
	-no preemption: 프로세스가 어떤 자원의 사용을 끝낼 때까지 그 자원을 뻇을 수 없다
 	-circular wait: 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있따.
-위의 발생을 막으면 교착상태deadlock을 막을 수 있다.

#기아상태starvation
-프로세스의 우선순위가 낮아서 원하는 자원을 계속 할당받지 못하는 샅애
-여러 프로세스가 부족한 자원을 점유하기 위해 경쟁를 할때, 특정 프로세스는 영원히 자원 할당이 안되는 경우를 주로 의미함
-우선순위를 변경해서 해결한다 FIFO기반 요청큐