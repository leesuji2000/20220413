#프로세스와 컨텍스트 스위칭
-스케줄러가 A프로세스에서 B프로세스로 바꿔줄때, 바꿔주는 메커니즘을 컨텍스트 스위칭이라고 한다.
-이 메커니즘을 이해하기 위해서 프로세스 구조를 이해해야한다.(디버깅을 깊게 고민할 때)

#프로세스는 일반적으로 어떤 구성을 가지는가
- 스택, 힙, 데이터, 코드 영역으로 이루어짐
	(바이널: 소스코드를 컴퓨터가 이해하기 쉬운 언어(어셈블리어)로 바뀌는 과정)
-소스영역에 소스코드를 넣고
-데이터영역에 변수를 넣는다(정적, 전역변수)
-스택영역에는 함수의 매개변수, 지역변수를 넣는다.(동적으로 없어졌다 생겼다가 하는 변수), 리턴 주소값도 저장
-힙영역 malloc함수(동적할당변수)를 이용해서 만든 변수 저장

=> 스택에는 코드가 실행될때 스택 자료구조에 따라서 먼저 들어오면 나중에 나간다.
 void add(int a, int b) {
	int sum = a + b;
}

int main(int argc, char **argv){
	add(2, 4);
	return 0;
}
일때 스택영역(스택 프레임이라고 부르기도 함)에는
1. int main 함수를 찾아 return 주소값을 저장(return 0 의 주소값이 아니라 int main 의 자체적 리턴주소값이 따로있다.)
2. argc, argv 변수 저장
3. add 함수가 끝나고 나서 main 함수로 올 것이기 때문에, main 함수의 return 0에 해당하는 주소값저장
4. add의 매개변수  a = 2, b = 4 저장
5. add함수 안에 있는 sum = 2 + 4 저장

그리고 5 4 3 2 1 순서로 나가게 된다.

#프로세스와 레지스터와의 관계
-text(code): 코드
-dat: 변수/초기화된 데이터
-stack: 임시 데이터(함수 호출, 로컬 변수 등)
-heap:코드에서 동적으로 만들어지는 데이터
pc(program counter) + sp(stack pointer)
pc: 실행하는 코드 한줄 위치
sp: 스택데이터에 들어온 변수 또는 주소
레지스터 중에 EBP라는 것이 있는데 EBP에는 sp의 최상단에 있는 값이 저장되어있다(함수가 시작될때마다 함수에 맞는 주소들 들어간다)
	=> 함수를 여러개 실행시켰을떄, 어떤 함수에서 문제가 일어났는지 찾기위해서 최상단(시작)주소를 저장하고 있다.
c언어로 작성된 프로그램의 디버깅을 할때 위의 개념은 중요하다

int main(){
	int *data;
	data = (int*) malloc(sizeof(int));
	*data = 1;
	printf("%d\n", *data);
	return 0;
}

힙영역:
1. data = (int*) malloc(sizeof(int));
2. *data =1 에 의해서 1 저장
스택영역:
1. int main의 return 주소값
2. int *data;(data = 주소값 저장)

#데이타 영역의 2가지 부분
-BSS: 초기화되지 않은 전역변수
-DATA: 초기화 된 전역변수

스택 오버플로우: 주로 해커들의 공격에 활용되었음(프로세스 기법을 이용)
	스택영역에 있는 데이터를 오버플로우로 만들어서 원래 값을 다른 주소로 바꿔서 자신이 원하는대로 바꿈
	문자열6 다음에 다른 변수(a)의 값이 저장되어 있을떄 문자열 7번째에 접근하게 되면 다른변수(a)값을 바꿀 수있다.
	이것을 이용해서 해킹을 할 수 있다.


#프로세스와 컨텍스트 스위칭
-pc, sp가 중요하다(스택, 힙, 데이타(BSS, DATA), text(code)구조 이해 중요
-컨텍스트 스위칭이란 A프로세스에서 B프로세스로 바꿔주는 것을 말하는데
 A프로세스를 실행하다가 pc, sp의 주소를 PCB위치에 저장하고 A프로세스 중지 후에, B프로세스로 바꾼다.
각 프로세스는 PCB를 가지고 있다

#PCB(process control block)
-sp, pc를 저장하는 공간
-process ID 레지스터값(pc, sp등), 스케줄러 상태 정보, 메모리 사이즈 값들을 저장하고 있다

//프로세스 구조: stack, heap, data(BSS, DATA), text(code)
//PCB: process state info, pc, sp, memory, scheduling info =>실행시간이 길어서 어셈블리어로 이루어졌다.

#context switching(문맥교환): cpu에 실행할 프로세스를 교체하는 기술
	1. 실행 중지할 프로세스 정보를 해당 프로세스의 pcb에 업데이트해서, 메인 메모리에 저장
	2. 다음 실행할 프로세스 정보를 메인 메모리에 있는 해당 pcb정보를 cpu의 레지스터에 넣고 실행,
-프로세스1 에서 프로세스 2로 변할때) 프로세스 1 pcb정보를 메인메모리에 저장, 프로세스 2 pcb정보를 메인메모리에 로드)
-굉장히 짧은 시간에 바뀐다

*디스패치(dispatch): ready 상태의 프로세스를 running 상태로 바꾸는 것(pcb정보를 cpu의 레지스터에 넣고, 실행(메모리에 로딩))

#컴파일러
-초기컴퓨터 프로그램은 어셈블리어로 작성되어 서로 다른 cpu아키텍처가 등장할때마다 일일이 다시 작성해줘야 했다.
-컴파일러 등장 이후 -> cpu아키텍처에 따라서 컴파일러 프로그래만 만들면 됨, 하지만 어셈블리어보다 속도가 느림

어셈블리어는 해킹이나 보안 쪽을 배울떄 배우는 것이지, 프론드앤드+백앤드와 같이 프로그램 만들때는 사용하지 않는다. 


#프로세스간 커뮤니케이션(interProcessCommunication)-IPC
-왜 필요한가? 프로세스들끼리 서로의 공간에 쉽게 접근하면 해킹위험, 하지만 성능을 높이기 위해서 여러 프로세스를 만들어 동시실행
	이때 프로세스간 상태 확인 및 데이터 송수신 필요
예를 들어 fork()시스템콜 함수: 프로세스 자신을 복사해서 새로운 프로세스로 만드는 함수 => 이 함수로 여러 프로세스를 동시에 실행 시킬 수 있다. (8cpu사용할때)
	1개cpu가 10분 걸리는데, 10cpu가 1분 걸릴 것이다 => 프로세스 간의 커뮤니케이션이 필요한 이유
	웹서버 -> 웹에서 요청이 올때마다, fork()로 새로운 프로세스를 만들고, 사용자에게 즉시 대응
-프로세스가 서로 정보공유는 힘들지만 SSD저장매체를 이용해서 공유하는 것은 가능하다(ipc기법 중 하나_
	FILE을 사용해서 실시간으로 직접 원하는 프로세스에 데이터 전달이 어려움, 왜냐하면 해당 프로세스가 파일을 읽어야하는데, 계쏙 실시간으로 읽으면 시간이 오래걸리기 때문이다.
