#페이지 교체 정책(페이지 수왑 알고리즘)
프로세스 1 2 3 가 있을때, 메모리에 데이터가 적재되었다고 하자 -> 메모리에서 데이터를 사용해야할때 어떤 것과 교체할지의 정책
=> FIFO알고리즘: 먼저 들어온애를 먼저 나가도록 교체한다.
=>OPT: 앞으로 가장 오랫동안 사용하지 않을 페이지를 내리기-> 최적페이지교체알고리즘 (신의 영역 불가능 =예측 불가)
=>LRU: 가장 오래전 사용된 페이지를 교체한다(OPT랑 비슷하게 만들기 위해 과거 기반 알고리즘) **가장 자주 사용
=>LFU: 가장 적게 사용된 페이지를 내리자
=>NUR: LRU처럼 최근에 사용하지 않은 페이지부터 교체하지만, 각 페이지마다 참조비트(read), 수정비트(write)를 정하고 교체한다

#메모리 지역성: 메모리는 그 주변에 있는 메모리를 사용할 확률이 높기 때문에(경험상) 오래전에 사용한 메모리 데이터 먼저 교체한다
#스레싱: 반복적으로 페이지 폴트가 발생해서, 과도하게 페이지 교체작업이 일어나, 실제로 아무일도하지 못하고, 스왑(데이터 바꾸기)만 이루어지는 상황
	-프로세스 너무 많이 띄어 놓으면 렉만 걸린다.

#가상메모리의 한 종류인 세그멘테이션(segmentation)
#세그멘테이션 기법
	-가상 메모리를 서로 크기가 다른 논리적 단위인 세그먼트로 분할
	-페이징 기법에서는 가상 메모리를 가상 메모리를 같은 크기의 블록으로 분할
	-세그멘테이션에서는 서로다른 크기의 세그먼트 단위로 분할 <-> 페이징 기법에서는 같은 크기(4KB)의 블록 단위로 분할
	-예시) CS(code segment), DS(data segment), SS(stack segment)등으로 나눠서 관리

#세그먼트 가상 주소
v = (s,d) //s는 세그먼트 번호, d는 블로내 세그먼트의 변위
//물리주소 계산 방식은 페이징 기법이랑 유사하다
세그먼트 단위의 가상주소 v = (s, d) -> 레지스터의 seg table주소 -> 세그먼트 테이블 -> 물리주소

#페이징 기법과 세그멘테이션 기법
페이징 기법 - 내부단편화: 같은 크기의 페이지 블록만큼 데이터가 딱 막게 채워지지 않았을때 공간 남비
세그멘테이션 기법 - 외부 단편화: 물리 메모리가 원하는 연속된 크기의 메모리를 제공해 주지 못하는 경우가 있다.
페이징 기법과 세그멘테이션은 둘다 하드웨어 기원이 필요하다
	-다양한 OS에 이식성을 중요하기 때문에 페이징 기법을 잘 사용한다.

#실제 프로세스가 메모리를 사용하는 방법(가상메모리 총정리)

아래 파일 읽는 예시
 #include <unistd.h>
#include <wyw/typed.h>
#include <sys/stat.h>
#include <tcntl.h>

int main() {
fd = open('data.txt', O_RDONLY); // open()시스템 콜 호출 -> 커널 모드 전환 -> open()함수를 처리하는 sys_open()커널 함수 호출 -> 파일 열기의 연산 수행 -> 사용자 모드 전환 -> open()이후의 프로그램 실행
if (fd == -1) {
 	printf("Error: can not open file.:");
	return 1;
}
else 
	{
		printf("File opened and now close");
		close(fd);
		return ();
	}

위 파일을 컴파일 -> 실행파일 생성 -> 실행파일이 쉘을 통해서 실행 -> 프로세스 -> 가상메모리 4GB 만들어짐(0~3: 사용자영역, 3~4: 커널영역)
4GB 안에는 4KB로 된 페이징들로 이루어져 있고 페이지의 모임인 페이징 테이블로 이루어져 있다. -> 페이징 테이블이 공간 차지, 불필요할 수 있어서 디렉토리를 만들어서 필요없는영역을 정하고, 필요부분만 메모리적재
각 프로세스마다 커널 공간이 있는데, 커널 공간에 해당하는 페이지 테이블이 가리키는 물리적 주소를 공유할 수 있다.(공간낭비 줄임)

코드가 가상메모리로 올라갔을때, 실행하기 전까지 메모리에 바로 적재되지 않는다. -> lazy allocation이라고 부른다. 
실행파일도 저장매체 있는데, 저장매체에서 정보를 읽어서 메모리에 올리는것은 시간이 오래 걸린다. 
	> 실행파일이 가상메모리에 올리고 나서, 꼭 필요할 때만 물리메모리에 올린다(요구페이징)=> 페이징 폴트를 하면서 하드웨어MMU, TLB도움을 받아서 데이터를 메모리에 적재

//가상메모리 주소 -> TLB에 있는지 확인하고 없으면 MMU의 도움을 받아서 페이징 테이블에 맞는 물리메모리를 가져온다
//실행파일이 만들어지면 가상메모리 4GB가 만들어지고 그중에서 커널 부분은 대부분 다른 프로세스와 같은 물리 메모리를 공유한다(공유메모리), 그리고 필요한 데이터들만 디렉토리로 묶어서 가상메모리에 적재, 필요없는건 따로 디렉토리 만들어서 관리
	만일 실행파일이 정말 실행이 필요하게 되면 요구페이징을 이용해서 가상메모리가 물리메모리를 데리고 온다

#왜 각 프로세스가 커널메모리를 가지고 있어도 용량에 크게 문제가 없나? -> 물리주소의 같은 곳을 공유하기 때문


#파일시스템: OS가 저장매체에 파일을 쓰기 위한 자료구조 또는 알고리즘
	-파일 시스템이 만들어진 이유: 0과 1로 데이터를 어떻게 저장매체에 저장할까? 비트로 관리하기는 오버헤드가 너무 큼, 블록 단위로 관리하기로 함, 블록마다 고유번호를 부여해서 관리
	사용자가 각 블로 고유 번호 관리 어려움(추상적 -논리적 객체 필요 => 파일 ), 사용자가 파일단위로 관리(파일 안에서 블록 단위로 관리)
	-저장매체에 효율적으로 파일을 저장하는 방법: 연속적인 공간에 파일을 저장하는것이 좋을것 -> 파일의 크기가 다 다르기 때문에 외부단편화, 파일 사이즈 변경문제로 불연속 공간에 파일저장 기능 지원이 필요
	-블록체인: 블록을 링크드 리스트로 연결(첫 블록 주소만 갖고 연결리스트를 이용해서 사용 -단점: 첫번째부터 연결해서 접근해야 한다.)
	 //인덱스 블록 기법: 각 블록에 대한 위치정보를 기록해서, 한번에 끝 블록을 찾아갈 수 있도록 함(주소에 바로 접근-인덱스로)

#파일 시스템 예시 
	-window: fat, fat32, ntfs(블록 위치를 fat라는 자료구로에 기록), 리눅스: etxt2

#파일 시스템과 시스템 콜
-동일한 시스템콜 함수를 사용해서 다양한 파일 시스템 지원 가능토록 구현
-os에서 알아서 시스템 콜을 통일 시켜서, 사용자는 어떤 파일 시스템을 쓰는지에 따라서 각각 다른 함수를 사용할 불편함을 줄일 수 있따.

#운영체제에서 다루는 파일 시스템 inode방식
	inode의 3개의 블록 타입
	-수퍼 블록: 파일 시스템 정보
	-아이노드 블록: 파일 상세 정보(프로세스의 PCB같은 기능)
	-데이터 블록: 실제 데이터(1KB~4KB)
#슈퍼블록: 파일 시스템 정보 및 파티션 정보 포함
#파일과 inode의 관계: 
	-파일: inode 고유값과 자료구조에 의해 주요 정보 관리
	-파일 이름: inode로 파일 이름은 inode번호와 매칭
	-파일 시스템에서 inode를 기반으로 파일 엑세스
	-inode기반 메타정보란? 파일 권한, 소유자 정보, 파일 사이즈, 생성시간등의 시간관련, 데이터 저장 위치의 정보를 이야기한다.
	
//프로세스를 생성하면 프로세스ID가 생성되고 그 정보를 PCB에 저장한다., 그리고 스케줄러가 PCB를 이용해서 여러 작업을 하듯
//파일을 생성하면 inode번호가 생성되면 inode블록이 생겨서 그곳에 상세정보가 저장되어, 파일처리를 하게 된다.
//슈퍼블록은 여러 파일을 포함하고, 각각의 파일은 inode번호가 할당되고 inode에 상세 정보가 저장되어있다.

디렉토리 엔트리: /home/ubuntu/ink.txtㅊ럼 각 디렉토리 엔트리를 탐색(각 엔트리는 해당 디렉토리 파일과 정보를 갖고 있다.)

//어떤 파일 시스템을 쓰든지 운영체제가 알아서 통일된 시스템 콜 함수를 사용하게 해준다고 했다. -> 가상파일 시스템(VFS): network등 다양한 기기도 동일한 파일 시스템 인터페이스를 통해 관리 가능-> 어떤 기기든 통일된 내부 함수
	모든 디바이스, 마우스 키보드들을 파일로 다루어진다 -> VFS를 통해서 모든 자원에 대해 동일(블록 디바이스와 캐릭터디바이스 -용량에 따라 구분)