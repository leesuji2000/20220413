#스테줄링 알고리즘 기본

#프로세스 = 실행중인 프로그램 = 메모리에 올려져서, 실행중인 프로그램(폰노이만 구조)
#코드이미지(바이너리): 실행파일, ELF format

#프로세스라는 용어는 작업, task, job이란 혼용해서 쓰임
#응용프로그램 ! = 프로세스
	응용프로그램은 여러개의 프로세스로 이루질 수 있다
하나의 응용프로그램의 여러개의 프로세스(프로그램)가 상호작용을 하면서 실행될 수도 있음
	간단한 C/C++ 프로그램을 만든다면? -> 하나의 프로세스
	여러 프로그램을 만들어서, 서로 통신하면서 프로그램을 작성할 수도 있음(IPC기법)

#스케쥴러와 프로세스
	누가 프로세스 실행을 관리할까요? 스케쥴러
	
#스케쥴러 알고리즘
-어느 순서대로 프로세스를 실행시킬까?(언제 교체하고 끼워넣을지)
-목표: 시분할 시스템(응답시간 축소), 멀티프로그래밍(cpu활용도 최대) -> 목표가 뭐냐에 따라 알고리즘이 다름

#FIFO 스케쥴러(가장 간단한 스케줄러) ->배치처리 시스템과 비슷
-프로세스가 저장매체를 읽는다든지, 프린팅하는 작업 없이 쭈욱 cpu을 처음부터 끝까지 사용한다고 가정하자
-FCFS(first come first served)스케줄러라고 부르기도 한다

#FIFO는 큐에서 배운 내용이다.
-큐를 이용해서 배치처리시스템을 구현했다.

#최단 작업우선(sortest job first_SJF) SJF 스케쥴러
-가장 프로세스 실행시간이 짧은 프로세스부터 먼저 실행을 시키는 알고리즘
-실행시간을 이미 다 알고 있다고 가정하자(현실에서는 실행시간을 알 수 없기 때문에 SJF는 이상적인 알고리즘이라고 생각하자)
-단점: 실행시간을 미리 다 알고 있어야한다.

realTime OS(RTOS): 응용프로그램 실시간 성능 보장을 목표로 하는 OS(시간이 민감한 프로그램을 쓸때 사용)
	-정확하게 프로그램 시작, 완료 시간을 보장(공정에서 쓰임(공장같은곳))
	-하드웨어 RTOS, software RTOS
general purpose(GPOS)
	-프로세스 실행시간에 민감하지 않고, 일반적인 목적으로 사용되는 OS
	-예시 윈도우, 리눅스

#우선순위 기반 스케쥴러 -> priority-Based 스케쥴러
-우선순위를 정할떄,
	-정적우선순위(프로세스마다 우선순위를 미리 지정) -> 일일이 다 순위를 정하는 번거로움
	-동적 우선순위(스케쥴러가 상황에 따라서 우선순위를 동적으로 변경) 

#round robin 스케줄러(FIFO랑 시분할시스템 합친거)
-미리 들어온 애들을 실행하되 실행을 쪼개서 여러 프로그램이 동시에 실행되는 거처럼 보인다.
-실행시간이 긴 것이 먼저 들어가도 시분할시스템을 따르기 떄문에 늦게 들어간 실행짧은 프로그램이 더 빨리 끝날 수 있다.

//다양한 기본 스케쥴링 알고리즘(FIFO=FCFS(배치처리시스템), SJF, 우선순위기반(정적, 동적 우선순위), RR 스케줄링(시분할시스템기반))


#프로세스 상태와 스케줄링 관계

#멀티프로그래밍과 wait
-멀티프로그램: cpu활용도 극대화하는 스케줄링 알고리즘
-wait: 간단히 저장매체로부터 파일 읽기를 기다리는 시간으로 가정
program A: (run) (------wait---) (run) (------wait----)
program B: (wait) (--------run) (-------wait----------)
program C: (wait------------------------)(-----run----)
result(결과): (A_run) (B_Run-----)(A_run)(C_run-------) => A B C 를 실행하면서 cpu활용을 극대화하고 있다.

어떤 시점에 어떤 프로그램을 실행시킬지?
	프로세스 상태 점검필요

#프로세스 상태 정의
-runnig state: 현재 cpu에서 실행상태
-ready state: cpu에서 실행가능상태(실행대기상태)
-block state: 특정 이벤트 발생 대기상태(ex- 프린팅이 다 되었다 = wait(저장매체))
프로세스 생성 상태 => ready state <-> running state <-> block state <-> ready state(삼각관계)  => 종료상태

#ready running block 삼각관계
-running 상태에 있다가 파일 읽기를 하면 block (process blocks for input)
	block에서 runnnig 상태로 바뀌는 것X, 그것은 스케줄러가 하는 일
-block에서 ready상태로 변경이 되면( cpu가 그 다음에 실행할 프로세스가 뭐뭐뭐 있니? 물어보는 상황)
-ready에서 running(스케줄러가 정해서 실행함)
-runnig -> ready(시분할 시스템이라서 쪼개서 바꿔치기)
*
#ready running block 상태를 이용한 스케줄링
-ready state queue, running state queue, block state queue를 만들어서 *큐의 FIFO*에 의해서 실행시킨다(cpu에서 아무것도 안하는 상태를 idle상태라고 한다)
-큐를 기반으로 하거나 우선순위(동적, 정적), SJF 등 알고리즘에 따라 실행순서가 달라진다 -> 최신 알고리즘은 훨씬 더 복잡하다.

#선점형 + 비선점형 스케줄러
-선점형 스케줄러(preemptive scheduling): 하나의 프로세스가 다른 프로세스 대신에 프로세서cpu를 차지할 수 있다.
	시분할시스템에서 cpu가 알아서 프로그램을 중간에 중지하고 다른 프로그램을 불러옴(현재 사용)
-비선점형 스케줄러(non-preemptive scheduling): 하나의 프로세스가 끝나지 않으면 다른 프로세스cpu를 사용할 수없음
	하나의 프로그램이 끝나거나 block상태에 있어야만 다음 프로그램이 실행(알아서 실행중단시킬 수 없음 -> 과거에 사용)

#선점형과 비선점형 스케줄러 차이
-비선점형은 프로세스가 block상태거나 끝났을때, 다른 프로세스로 교체
-선점형은 프로세스 runnning중에 스케줄러가 이를 중단시키고, 다른 프로세스로 교체(비선점형보다 훨씬 좋음)

#스케쥴러 구분: FIFO, SJF, priority-based, roundrobin 등등
-비선점형 FIFO, SJF, priority-based
-선점형: roudrobin 

#우선순위기반(정적), 선점형, 시분할, 프로세스 상태 -> 이것들 이용하고 조합해서 스케줄러를 만든다

-쉘과 같이 반응이 빨라야하는 것을 정적으로 우선순위를 주는 스케줄러를 만들면 좋다.
 
#렉: 마우스, 키보드 반응이 느린 경우?
-스케쥴러가 해결해야 하는 이슈
-다양하고 복잡한 스케쥴링 알고리즘 필요
=> 리눅스  스케쥴러: O(1), CFS와 같은 스케쥴링 방법으로 다양하게 시도ing
	인터렉티브(쉘같은 반응 빨라야 하는거), IO, cpu 중심 프로세스로 미리 구분할 수 잇으면 개선된 스케줄링 제작 가능

#스케줄링 알고리즘- 인터럽트
-cpu가 프로그램을 실행하고 있을때, 입출력 하드웨어 등의 장치나 또는 예외 상황이
	발생하여 처리가 필요할 경우에 cpu에 알려서 처리하는 기술 
-어느 한 순간에 cpu가 실행하는 명령은 하나, 다른 장치와 어떻게 커뮤니케이션 할까?
	이벤트가 발생했을때, cpu에 이를 알리는 것을 인터럽트라고 한다.

#인터럽트 필요이유
	-선점형 스케줄러 구현: running중에 스케줄러가 이를 중단하고, 다른 프로세스로 교체하기 위해 현재 프로세스 실행을 중단 시킴
				그러려면, 스케줄러 코드가 실행되어, 현 프로세스 실행을 중지시켜야 한다.
-선점형 스케줄러 구현을 위해서 인터럽트가 필요하다.
-예외 상황 핸들링: cpu프로그램을 실행하고 있을때, IO하드웨어 장치나 예외 상황이 발생했을때, cpu가 해당 처리를 할 수 있도록 cpu에 알려줌
	예를 들어 0으로 나눈다 코드가 있을때, 컴퓨터가 너무 뜨거워 졌을때 등등
#인터럽트 처리 예시
-cpu가 프로그램을 실행하고 있을때, IO 하드웨어 등 장치 이슈발생 -> 파일 처리가 끝났다는 것을 os에 알려주기ㅣ-> os는 해당 프로세스를 block상태에서  ready상태로 변경
 	또는 예외 상황 발생: 0으로 나누는 계산이 발생하면 os에 알려서 실행 중지

#이벤트와 인터럽트
-인터럽트는 이벤트의 한 종류이다. (block을 일으키는 일 = 이벤트 = 인터럽트)

#타이머 인터럽트(선점형 스케줄러에 중요함)
-선점형 스케쥴러를 위해서 타이머 인터럽트가 일정시간마다 프로세스를 교체
-하드웨어로부터 일정 시간마다 타이머 인터럽트를 운영체제 알려줌

#입출력 인터럽트
-프린터, 키보드 , 마우스 , 저장매체 전용 IO 인터럽트가 각각있다.

#인터럽트 종류
-내부인터럽트: 주로 프로그램 내에서 잘못된 명령 또는 잘못된 데이터 사용시 발생
	 0으로 나눴을때, 사용자모드에서 허용되지 않는 명령 또는 공간 접근(포인터 잘못사용)
	계산 결과가 overflow/underflow날떄
-외부인터럽트: 주로 하드웨어에서 발생되는 이벤트(프로그램 외부)
	전원이상, 기계문제, 키보드 같은 IO관련 이벤트, timer 이벤트
-내부인터럽트를 소프트웨어 인터럽트라고 부르기도하고
-외부인터럽트는 하드웨어 인터럽트라고 부르기도 한다.

#시스템 콜 인터럽트
-시스템콜 실행을 위해서는 강제로 코드에 인터럽트 명령을 넣어, cpu에서 실행시켜야 한다.
-시스템콜 실제 코드
	-eax 레지스터에 시스템 콜 번호를 넣고(시스템 콜에 각각 번호가 있고, 그 번호에 해당하는 함수들이 있다.)
	-ebx 레지스터에는 시스템 콜에 해당하는 인자값을 넣고(함수의 인자 = 매개변수)
	-소트프웨어 인터럽트 명령을 호출하면 어떤 값에 넘겨준다.(인터럽트도 번호가 있어서 그 번호를 넘겨준다.)

	-컴퓨터는 우리가 소스코드를 쓰면 내부적으로 어셈블리어로 바뀐다.
	-mov eax, 1 =>eax 레지스터에 시스템 콜 번호를 넣기
 	-mov ebx, 0 =>bx 레지스터에는 시스템 콜에 해당하는 인자값을 넣기
	-int 0x80 => 소트프웨어 인터럽트 명령을 호출하면 0x80 값에 넘겨준다

#인터럽트와 시스템 콜(고급)
-시스템콜 인터럽트 명령을 호출하면서 0x80값을 넘겨준다.
	1. cpu는 사용자 모드를 커널 모드로 바꿈(int라는 opcode가 사용자->커널 모드로 바꿔준다.)
	2. IDT(interrupt descriptor table=특정주소(인터럽트번호와 주소값이 표로 만들어져 있음)에서 0x80에 해당하는 주소(함수)를 찾아서 실행
	3. system_call()함수(0x80 = 함수주소)에서 eax로부터 시스템 콜 번호를 찾아서, 해당 번호에 맞는 시스템콜 함수로 이동
	4. 해당 시스템콜 함수 실행 후, 다시 커널 모드에서 사용자 모드로 변경하고, 다시 해당 프로세스 다음 코드진행

=> 위는 고급 내용이므로 이해하기 어렵겠지만 4단계 정도는 알아두자
//cpu는 사용자 모드에서 커널 모드로 변환 -> 번호에 해당하는 함수를 찾아 실행 
	-> 찾은 함수에서 시스템콜 번호를 찾아서, 해당 번호에 맞는 시스템 콜 할수로 이동 -> 시스템할수 실행후 커널모드에서 사용자모등로 변경하고 다음 코드실행


-프로세스가 cpu에서만 실행하는 것이 아니라
 	인터럽트에 의해서 커널모드와 사용자모드를 왔다가 갔다가 하면서 실행된다.

#인터럽트와 IDT 관계
-인터럽트는 미리 정의되어 각각 번호와 실행코드를 가리키는 주소가 기록되어있다.
-그 기록은 IDT에 기록되어있다
-컴퓨터가 부팅할때 os가 IDT를 기록한다
-운영체제 내부 코드이기 때문에 커널모드에서 실행된다.

-항상 인터럽트 발생시, IDT를 확인
-시스템콜 인터럽트 명령은 0x80번호가 미리 정의
-인터럽트  0x80에 해당하는 운영체제 코드(코드주소)는 system_call()이라는 함수
-즉, IDT에서 0x80 -> system_call()와 같은 정보가 기록되어 있다

예를 들어 리눅스의 경우
0~3`: 예외상황 인터럽트(일부는 정의안된 채로 남겨있다.)
32~47: 하드웨어 인터럽트(주변장치 종류/갯수에 따라 변경 가능)
128: 시스템 콜

순서: 프로세스 실행 중 인터럽트 발생 -> 현 프로세스 중단 -> 인터럽트 처리 함수 실행(os) -> 현 프로세스 재실행


선점형 스케쥴러 구현 예시
-수시로 타이머 인터럽트 발생: os가 타이머 인터럽트 발생 횟수를 기억해서 5번 타이머 인터럽트 발생하면
		현재 프로세스를 다른 프로세스로 바꿔준다



 

