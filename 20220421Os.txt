#가상메모리
-프로세스 관련 기술과 비슷한 면이 있다.
-리눅스는 하나의 프로세스가 4GB를 가진다.
-통상 메모리는 8gb 16gb인데 2개 3개 프로세스만 작동 가능? no -> 적은 메모리로 여러 프로세스 작동하기 위해서 가상메모리 
-프로세스 A B C 가 4GB라고 해도 Cpu를 참조하지 않는 공간들이 있기 때문에, cpu가 필요한 공간만 cpu에서 작동하도록

#가상메모리가 필요한 이유
-하나의 프로세스만 실행 가능한 시스템(배치처리시스템 등)
-프로그램을 메모리로 로드 -> 프로세스 실행 -> 프로세스 종료(메모리 해제)
-여러 프로세스 동시 실행 시스템
	-메모리 용량 부족 이슈
	-프로세스 메모리 영역간에 침범 이슈

#가상메모리: 메모리가 실제 메모리보다 많아 보이게 하는 기술
	-실제 사용하는 메모리는 작다는 점에서 착안해서 고안한 기술
-가상 메모리 기본 아이디어
	-프로세스는 가상 주소를 사용하고, 실제 해당 주소에서 데이터를 읽고/쓸때만 물리 주소로 바꿔주면 된다
	-가상주소: 프로세스가 참조하는 주소 // 물리 주소: 실제 메모리 주소
 	-매번 주소를 참조하고 변환하는데 시간이 걸리기 때문에 MMU라는 것을 사용
-MMU: cpu에 코드 실행시, 가상 주소 메모리 접근이 필요할때, 해당 주소를 물리 주소값으로 변환해주는 하드웨어 장치

#가상메모리와 MMU관계
-cpu가 가상 메모리를 가지고, 가상메모리가 실제 해당 주소 접근시 MMU하드웨어 장치를 통해 물리 메모리 접근
	(cpu) -(virtual address)-> MMU -(physical address)-> memory
	하드웨어 장치를 이용해서 주소변환이 빠르기 때문에 별도 장치를 둠

#페이징 시스템: 가상메모리를 만들기 위한 메커니즘
-페이징 개념
	-크기가 동일한 페이지로 가상주소공간과 이에 매칭하는 물리주소공간을 관리
	-하드웨어 지원 필요(intel x86 시스템에서 4kb, 2mb, 1gb지원)
	-페이지 번호를 기반으로 가상주소/물리주소 매핑 정보를 기록/사용
	cpu가 가상주소 부르면 -> 가상 주소에 해당되는 페이징 위치를 찾고 -> 페이징 위치에 매칭되는 물리주소 공간 접근

#페이징 시스템 구조
-페이징(페이징 프레임): 고정된 크기의 4KB
-가상주소 v = (p, d) 
	//p: 가상 메모리 페이지, d: p안에서 참조하는 위치(변위, 차지하는 공간 크기)
-페이지 크기가 4KB인 예
	-가상 주소의 0비트 ~ 11비트가 변위(d)를 나타내고
	-12비트 이상이 페이지 번호가 될 수 있음

#페이지 테이블
-물리주소에 있는 페이지 번호와 해당 페이지의 첫 물리 주소 정보를 매핑한 표
-가상주소 v =(p, d)라면
	p: 페이지 번호//d: 페이지 처음부터 얼마 떨어진 위치인지

-페이지 시스템 동작
	-해당 프로세스에서 특정 가상 주소 엑세스를 하려면
		-해당 프로세스의 페이지 테이블(PCB의 페이지 테이블 의 주소)에 해당 가상 주소가 포함된 페이지 번호가 있는지 확인
		-페이지 번호가 있으면 이 페이비가 매핑된 첫 물리 주소를 알아내고 (p)
		-p + d가 실제 물리 주소가 됨

#페이징 시스템과 MMU(컴퓨터 구조)
-프로세스 생성시, 페이지 테이블 정보 생서
	-PCB등에서 해당 페이지 테이블 접근 가능하고, 관련 정보는 물리 메모리에 적재
	-프로세스 구동시, 해당 페이지 테이블 base주소가 별도 레지스터에 저장 CR3
	-CPU가 가상 주소 접근시, MMU가 페이지 테이블 주소를 접근해서, 물리주소를 가져옴

#다중 단계 페이징 시스템 
-32bit 시스템에서4kb 페이지를 위한 페이징 시스템은 하위 12bit는 오프셋, 상위 20bit가 페이징 번호이므로, 2의 20승의 페이지 정보가 필요
>페이징 정보를 단계를 나누어 생성
	-> 필요없는 페이지는 생성하지 않으면서 공간 절약 가능
	-페이지 디렉토리, 페이지 테이블, 변위로 나눔
		페이지 디렉토리에 가면 페이지 테이블로 접근, 페이지 테이블에서 물리주소로 접근

#MMU와 TLB (컴퓨터 구조)
-MMU가 물리 주소를 확인하기 위해 메모리를 갔다와야 함
-cpu에서 가상 주소를 요청하면 -> MMU에서 레지스터CR3(base address)를 메모리에 있는 페이지 테이블에 요청하고
	-> 페이지 테이블에서 MMU에게 물리석 주소를 요청한다. 
	-> 요청 받는 MMU는 물리주소 접근을 위해 메모리에 있는 페이지 데이터에 접근 -> 디텍토리에 있는 데이터값 cpu에 전달

-> 메인메모리에 시간이 많이 걸리기 때문에
	TLB를 이용해서 이미 변환이 된 물리주소를 tlb(캐쉬)에 저장해서, 나중에 또 가상주소에서 물리주소를 요청할때, tlb에서 찾는다

#페이징 시스템와 공유메모리
-프로세스 간 동일한 물리 주소를 가리킬 수 있음(공간 절약, 메모리 할당 시간 절약)
	a프로세스를 fork()를 통해서 복사한 후에 한개의 동일한 메모리주소를 공유한다
 	만일에 a프로세스 (부모_원본)이 데이터 값을 바꾸면 그때는 메모리 주소를 새로 복사해서, 원본 a프로세스와 복제본 프로세스가 다른 메모리 공간을 가리킨다

=> 프로세스 생성 시간 단축, 커널&공유메모리든 공유데이타든 물리메모리를 공유해서 공간 절약

#요구페이징(demand paging)
-프로세스 모든 데이터를 메모리로 적재하지 않고, 실행 중 필요한 시점에만 메모리로 적재함
	-선행 페이징(anticipatory paging)의 반대개념: 선행페이지는 미리 프로세스 관련 모든 데이터를 메모리에 올려놓고 실행하는 개념이다
	-더이상 필요하지 않은 페이지 프레임은 다시 저장매체에 저장(페이지 교체 알고리즘 필요)
#페이지폴트(인터럽트라고 생각하면 됨)
-어떤 페이지가 실제 물리 메모리에 없을떄 일어나는 인터럽트(인터럽트 이후에 저장매체에 가서 메모리에 적재시키는 과정을 거쳐야한다.)
-운영체제가 페이지 포트가 일어나면, 해당 페이지를 물리 메모리에 올림

페이지 폴트가 자주 일어나면?
	실행되기 전에, 해당 페이지를 물리 메모리에 올려야한다.
	-시간 오래걸림
페이지 폴트가 안 일어나게 하려면?
	-향후 실행/참조될 코드/데이터를 미리 물리 메모리에 올리면 됨
	
