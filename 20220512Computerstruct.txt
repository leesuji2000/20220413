#마이크로 명령과 ALU

#마이크로 연산: 레지스터에 저장된 데이터로 수행되는 기본적인 연산
	-레지스터 사이에서 이진 정보를 전송하는 레지스터 전송 마이크로 연산
	-레지스터에 저장된 수치 데이터에 대해 산술 연산을 수행하는 산술 마이크로 연산
	-레지스터에 저장된 비수치데이터에 대해 비트 조작 연산을 수행하는 논리 마이크로 연산	
	-시프트연산을 수행하는 시프트 마이크로 연산 (<<, >>)

#산술논리연산장치 ALU: 산술연산과 논리 연산
	-주로 정수 연산을 처리
	-부동소수연산FPU
	-산술연산: 덧셈뺏셈감소보수증가
	-논리연산
ALU 제어신호(add, sub, or, and...) -> ALU -> 상태레지스터(C, Z, N, V, P//carry, zero, negative, overflow, panity(감시)) <-AC(임시저장)
cayy bit가 있으면 full 연산// carry bit가 없으면 half 연산

#산술연산 종류
ADD: X <- A + B
SUB: X <- A + (~B + 1)(빼기)
MUL: X <- A*B
DIV: X <- A / B
INC: X <- A+1
DEC: X <- A-1
NEG: X <- ~A + 1( A를 2의 보수로 변환)

#논리연산과 산술시트프연산
AND: X <- A&B
OR: X <- A|B
NOT: X <- ~A
XOR: X <- A^B
ASL: X <- A << n
ASR: X <- A >>n
LSL: X <-  A << n(ASL이랑 거의 비슷)
LSR: X <- A >>n
ROL: X<- A<<1(MSB:가장 왼쪽에 있는 bit를 LSB: 가장 오른쪽bit로 시프트)
ROR: X <- A>>1

masking: 두개의 비트를 and논리연산할때 앞(상위)에 4개를 0으로 만들어버림(unpackage에서 활용)
insert: 앞에 0000 4개인 것을 or논리연산을 이용해서 없앰(unpackage에서 package에서 활용)

#마이크로 명령어 집합과 구성
-명령어 집합
-주소 지정 모드

#명령어 집합
	-실행 순서에 따른 명령어 분류
		-순차적실행명령(주로 사용)
		-분기명령어(If, 선별적)
		-부 함수 호출 명령어(메인드라마 중간에 광고(부함수) 삽입하는거)
		-복귀 명령어
#명령어 구문 형식 (명령코드 + 오퍼랜드 주소 +주소지정모드)
-명령코드: cpu가 실행할 수 잇도록 디자인된 연산
-오퍼랜드: 연산에 사용되는 자료값, 자료가 저장된 주소에 관한 정보
-주소지정모드(addressing mode) : 오퍼랜드가 저장된 위치를 인덱싱(지정)하는 방법

=> 파이썬, 자바 등 새로운 언어가 등장하는 이유는 
	자연어보다 기계 중심의 명령코드가 cpu구조 설계 측면에서 표준화가 가능하고, 간편화될 수 있기 때문이다.