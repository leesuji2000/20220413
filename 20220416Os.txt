#운영체제 학습방법
문과 스타일: 일단 외우고 나서, 이해하기
핵심이론과 용어에 집중해서 감을 집중

운영체제는 여러 기술이 모여있기 때문에
다양한 기술들을 알고 있어야 전체적으로 이해할 수 있다. 

#운영체제 과목소개
-컴퓨터 사이언스(전공) 필수 과목
-컴퓨터 구조가 하드웨어 scratch라면
-운영체제는 software + hardware scratch
-자료구조, 알고리즘(큐, 스택)이 운영체제에서는 필요하다(효율 중요)
-프로그램을 작성할때 운영체제에 맞게 효율적으로 만들 수 있다.

#운영체제 역할: 시스템 자원(system resource)관리자
-OS라고 부름
-시스템자원 = 하드웨어
	하드웨어 종류: CPU(중앙처리장치), RAM(메모리), 
			I/O device(입출력장치-모니터, 마우스, 키보드, 네트워크(다른컴퓨터에서 입력받거나 보냄)
			SSD, HHD(저장매체: 컴퓨터를 꺼도 저장)
-OS는 하드웨어를 관리하는 시스템이다.

#운영체제 역할
-하드웨어느 스스로 할 수 있는 것이 없기 때문에
-cpu : 각 프로그램이 얼마나 cpu 를 사용할지를 결정할 수 없다
-memory: 각 프로그램이 어느 주소에 저장되어야 하는지, 어느정도 공간을 확보할지 결정할 수 없다.
-저장매체: 주소와 공간, 파일 또는 폴더 형태를 결정할 수 없다.
-I/O device: 입출력 방법에 대한 데이터 처리를 혼자 결정할 수 없다.(스스로 표시 불가)
=>OS가 이것들을 관리한다.

#대표적인 운영체제: 윈도우스, 맥킨토시, 리눅스, 유닉스
-유닉스 OS: 유닉스 계열 OS들이 있다(사용법과 구조가 유사) => 리눅스
-리눅스 OS: 인터넷 서비스를 구동 시키는 서버를 작업할 때 필요, 전공자들은 꼭 알고 있어야한다.

#OS는 많은 기술이 필요하기 때문에 만드는데 시간과 돈이 많이 들고, 버그도 많다.

#운영체제 역할2: user와 컴퓨터간의 컴뮤니케이션 지원
- user <-> OS  <-> 하드웨어

#운영체제 역할3: 하드웨어와 프로그램 제어
-응용프로그램(어플)과 하드웨어 사이에서 둘을 관리하는 역할
-운영체제가 응용프로그램을 실행시켜준다.

#응용프로그램이란?
-프로그램 = 소프트 웨어
-소프웨어 = 운영체제, 응용프로그램(엑셀, 파워포인트 등)
-응용프로그램 = Application(pc용어) = app(phone)

#운영체제와 응용프로그램간이 관계
-운영체제는 응용프로그램을 관리
	-응용프로그램을 실행시켜줌
	-응용프로그램 간의 권한을 관리해준다(관리자 권한으로 실행)
	-응용프로그램을 사용하는 사용자도 관리(로그인할때, 아이디를 넣어야 컴퓨터 시작하는 것들)
-응용프로그램은 누구나 만들 수 있지만 OS가 그것을 관리한다.
	-예를 들어 응용프로그램이 무한루프로 돌아서 컴퓨터가 위험에 처하면 OS가 강제종료시켜준다(관리하다)
	-악성코드가 들어와서 모든 파일을 삭제하려 할때 OS가 권한, 사용자 관리를 한다.
	-응용프로그램이 cpu를 전부 써버릴때, OS가 관리하여 이를 막는다.
-OS목표는 사용자가 사용하는 응용프로그램을 효율적이고 적절하게 동작하도록 지원
-운영체제는 응용프로그램이 요청하는 시스템 리소스를 효율적으로 분배하고, 지원하는 소프트웨어이다.

#운영체제는 어디에 있을까
-SSD, HDD에 있다.
-컴퓨터 전원을 키면 운영체제는 메모리에 올라가게 된다.(폰노이만 구조)

//응용프로그램의 역할: 시스템자원, 응용프로그램을 효율적으로 관리한다.


#운영체제 역사
-50년~60년대
	-에니악(ENIAC): 첫번째 컴퓨터 => 당시에 OS의 존재도 없고 필요성도 몰랐음
		-1개의 응용프로그램을 실행시키기도 힘들었음
		-OS가 없어서 응용프로그램이 직접 시스템자원을 제어했다
		-에니악은 진공관으로 0과 1을 표현해서 프로그램을 만든 컴퓨터인데 일일이 관리

-60년대 초기
	-프로그램 종류가 많아지고, 사용자도 많아지기 시작
	-문제점 발생: 두개의 프로그램을 실행시킬때, 실행시간이 적은것을 먼저하고 실행시간이 긴 프로그램을 작동시키거나
		그 반대로 하거나..실행순서를 정하는 문제 발생
			옛날 컴퓨터학과 학생들은 늦게 온 사람은 어플 실행 시간이 며칠 이상 걸렸다.
	-배치 처리 시스템(batch processing system)출현: 여러 응용프로그램을 등록시켜놓으면, 순차적으로 실행하는 시스템
	-배치 처리 시스템을 기반으로 운영체제 출현

#배치 처리 시스템 동작 방식
- (시간 100000000000000000000000시간-어플) (시간 100000시간-어플)가 있을떄
-어플을 등록 시키면 다음 어플이 실행시키는 것이 배치 처리 시스템이다.
-어플 순서에 따라 응용프로그램의 실행시간이 달라진다

-60년대 후반
	-새로운 개념: 시분할 시스템(time sharing system) & 멀티태스킹 
	-이론은 나왔지만 구현을 못했음

#시분할 시스템과 멀티태스킹 개념
-어플 실행시간을 여러번 쪼개서 번갈아 가면서 실행시켜, 동시에 같은 프로그램을 실행시키는 효과를 보이면서 실행시간도 줄인다.(전체적인 실행시간은 줄지 않는다.)
-응용프로그램이 cpu를 사용하는 시간을 잘개 쪼개서, 여러개의 응용프로그램을 동시에 실행하는 기법
-시분할시스템 목적: 다중사용자를 지원, 컴퓨터 응답시간 최소화
-멀티태스킹: 가능한 cpu를 많이 활용(시간대비cpu사용양 늘리기)

-멀티태스킹: 단일 CPU에서, 여러 응용프로그램의 병렬실행을 가능케하는 시스템, 사람 눈에는 동시에 보이도록 하는것
=> 시분할시스템이랑 멀티태스킹은 응용프로그램 시간을 쪼개서 실행시킨다는 점에서 같다.//내부적으로 각각 짧은 시간동안 실행되지만 사람눈에는 동시에 실행되는것처럼 보임
=> 시분할시스템과 멀티태스킹을 같은 것으로 보기도 한다.

-멀티프로그래밍(자세히 몰라도 됨): 최대한 cpu를 많이 활용하도록 하는 시스템(시간대비, cpu사용양 최대)
	-응용프로그램이 실행될때, cpu를 안쓰는 동안 다른 응용프로그램을 끼워넣어 실행시킴

#배치 처리 시스템의 단점
-컴퓨터 응답시간(response time)이 오래 걸릴 수 있다.(앞단에 실행한 응용프로그램 실행시간이 길경우)
-시행시간도 오래 걸릴 수 있다.(cpu필요없는 시간을 낭비)

#시분할시스템, 멀티태스킹 장점
-응답시간 줄일 수 있어 다중사용자를 지원(시분할 시스템)
-전체 응용 프로그램의 실행시간도 줄임(멀티 프로그래밍)
-결과적으로 사용자가 느끼기에 여러 응용프로그램이 동시에 실행되는 것처럼 보인다.(멀티태스킹)

//60년대 후반에는 시분할시스템/멀티태스킹 구현은 아니지만 아이디어는 나왔다.

-70년대
-유닉스, 데니스리치가 만듬(제대로된 운영체제)
-데니스 리치는 C언어를 만든 사람

#운영체제 개발에 c언어가 필요했던 이유
-어셈블리언어는 주소를 직접 쓰고 불편했기 때문에, 어려움, 각각의 컴퓨터마다 다시 개발해줘야하는 단점(프로그래밍 복잡도가 높음)
-70년대 이후에는 c언어가 개발되어, 컴파일러(컴퓨터에 맞게 어셈블리어로 바꿔줌)가 대신 작업해줘서 컴퓨터별로 개발할 필요 없다.
-어셈블리어와 비교할때, 복잡도가 낮다

#유닉스 특징
-현대 운영체제의 기본 기술을 모두 포함한 최초의 운영체제
-멀티태스킹, 시분할시스템, 멀티프로그래밍->다중 사용자 지원

-80년대(개인용 컴퓨터 시대)
	-80년대 이전: 대형 컴퓨터를 여러명이 접속해서 사용(유닉스-시분할 시스템, 멀티태스킹)
	-80년대 ~: personal computer(pc) 보급

#용어이해: CLI, GUI
	CLI(command line interface): 터미널// command를 쳐서 컴퓨터에 창을 띄워 컴퓨터와 소통(키보드로 입력하여 출력받는것)
	GUI(graphical user interface): GUI 환경 //키보드 대신 마우스로 버튼을 눌러서 결과를 얻는거

	-80년대부터 CLI(키보드) 에서 GUI(마우스)로 변했다.
		-애플 매킨토시에서 마우스를 이용한 GUI 

//80년대: 개인용 컴퓨터, GUI 컴퓨터
	

-90년대
	-응용프로그램 시대(GUI 환경, 개인용 PC-> 사용자 증대 (워드프로세서, 엑셀, 위도우 운영체제 대중화 등등)
	-네트워크 인터넷 기술 발전
	-오픈소스 운동 활성화 시작(유닉스 계열 OS + 응용프로그램 자체개발, 소스 오픈 -> 리눅스 운영체제 발생(무료사용가능))

#killer application 개념
	-엑셀 프로그램을 사용하기 위해서 , window OS컴퓨터 구매
 	-게임을 하기 위해서 플레이스테이션 기기 구매

//90년대: 다양한 응용프로그램, 네트워크 인터넷 발전, 오픈소스(리눅스), killer applicaton 증가

-2000년대 이후
	-오픈소스 활성화(리눅스, 아파치-웹서버, MYSQL(데이터 베이스), 요즘 안드로이드, 딥러닝, 데이터사이언스, IoT관련)
	-가상머신(운영체제 위에 가상 운영체제를 보이도록 하는 기술), 대용량 병렬처리(CPU가 여러개 CORE라고 부른다-> 속도 증가) 활성화

//50년대: 운영체제 없음(프로그램이 시스템 자원 직접 제어)
//60년대: 배치 처리 시스템
//70년대: 시분할 시스템, 멀티태스킹 (유닉스 C언어)
//80년대: GUI, PC
//90년대: 다양한 응용프로그램, 인터넷발달, 오픈소스
//20000: 오픈소스, 가상머신, 대용량병렬처리 시스템

//운용체제는 응용프로그램 + 시스템 자원을 제어, 관리
//응용프로그램(application) 용어 이해
//배치 처리 시스템, 시분할 시스템, 멀티태스킹 개념
//CLI, GUI 용어 이해
//역사 전반적인거 알아두기

#응용프로그램, 운영체제, 하드웨어 관계
	-운영체제를 도서관, 응용프로그램을 시민, 하드웨어는 책이라고 한다면
	-운영체재의 역할
		-시민은 도서관에 원하는 책을 요청, 도서관은 책을 찾아서 시민에게 빌려줌, 기간이 지나면 책 회수
	-운영체제는 응용프로그램이 요청하는 메모리를 허가하고, 분배
	-운영체제는 응용프로그램이 요청하는 CPU시간을 제공
	-운영체제는 응용프로그램이 요청하는 IO device사용을 허가, 제어한다.

#사용자, 응용프로그램, 운영체제, 컴퓨터 하드웨어와 관계
	사용자<->응용프로그램<->운영체제<->하드웨어(cpu, memory, storage, network)

#운영체제는 사용자에게 인터페이스제공
	-쉘(shell): 인터페이스(터미널)을 제공해주는 OS
		사용자가 운영체제 기능과 서비스를 조작할 수 있도록 인터페이스를 제공하는 프로그램
		쉘은 GUI와 CLI환경 두 종류로 분류

#운영체제는 응용프로그램을 위해서도 인터페이스를 제공
	-API(application programing interface)형태로 제공(함수형태로 제공)
		open(), printf()등의 함수를 묶어 라이브러리 형태로 제공(C라이러리)
	-시스템 콜 또는 시스템 호출인터페이스: 운영체제가 운영체제 각 기능을 사용할 수 있도록 시스템 콜이라는 명령, 함수를 제공
	-API 내부에는 시스템 콜을 호출하는 형태로 만들어지는 경우가 대부분

사용자 <-> application, shell <-> API(라이브러리) <->시스템 콜<-> OS <-> 하드웨어(cpu, memory,,,)

#운영체제를 만든다면
1. 운영체제 개발(kernel)
2. 시스템 콜을 개발
3. C API(라이브러리)
4. shell 프로그램
5. 응용프로그램 개발

#운영체제와 시스템 콜
	-시스템콜 정의 예시: 포직스 API(유닉스 시스템 콜도 포직스를 따른다)

//API: 각 언어별 운영체제기능 호출 인터페이스 함수(각 언어별 인터페이스) C API, JAVA API
//시스템콜: 운영체제 기능을 호출하는 함수
//사용자 인터페이스를 제공하기 위해서 쉘프로그램 사용
//응용프로그램이 운영체제 기능을 요청하기 위해서, 운영체제는 시스템 콜을 제공한다.
 	//보통 시스템 콜을 직접 사용하기 보다, 해당 시스템 콜을 사용해서 만든 각 언어별 라이브러리(API)를 제공








 